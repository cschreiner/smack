CAS notes on using and developing smack

[ ] Each file using smack assertions and other features must include smack.h.
Currently the whole directory to this file is required, like this:
#include "/uusoc/scratch/euler/cas/tuut/x86_64/smack-project/smack/install/include/smack/smack.h"

[ ] What does smack-verify.py's message "Finished with 0 verified" mean?
(from "Finished with 0 verified, xx errors").  I infer it does not mean
nothing was verified at all, or does it mean no assertions were verified?
TODO: verify this with ZR.

[ ] Question: in smack.h, there is a comment about the "2D memory model".
What distinguishes this model from other memory models?  Do I need to factor
this into my work somehow?

[ ] When smack runs on file file.c with `--verifier corral`, it creates these
object-ish files:
	   a.bpl
	   corraldebug.out
	   corral_out.bpl
	   corral_out_trace.txt
	   file.bc

   a.bpl seems to contain boogie code created by SMACK and fed to corral.
   corraldebug.out seems to contain very high-level reports from corral on the
	paths it explored, and what it found.
   corral_out.bpl then contains boogie code generated by corral?
   corral_out_trace.txt seems to contain info on paths explored by corral.
   file.bc contains LLVM bitcode, which SMACK then parses into bpl code.
	   
[ ] Debugging an assertion that should fail but isn't:
You open your bpl file and add "assert false;" to the beginning if main. You
invoke corral on this bpl file. Clearly, this "assert false" will fail since
it is in the beginning of main. Then, you keep moving "assert false;" through
your code until you find the exact instruction that causes "assert false" to
be vacuously true. Then you focus on figuring out what is wrong with that
instruction. And the problem will almost always be an assume instruction.
For example, this `assert false` won't yield an error:

	x := 1;
	assume x == 0;
	assert false;

[ ] __SMACK_assume( xxx ) means "either xxx is true, or exit()".

[ ] Smack mimics this feature of Boogie: if a loop runs for an indeterminate
number of times, the loop index value is havoc'd, and both the case of
continue-looping and end-looping are considered.  This is good.  However, if
the loop executes for a known, fixed number of times, and the number of
iterations exceeds the loop unrolling threshold (often about 2), then Boogie
and Smack act as if the program terminated at that loop.  Zvonimir sometimes
summarizes this by saying, "The program effectively exits at the end of the
loop."
_
Apparently a few years ago there was a proposal at Microsoft Research (where
Boogie was created) to have Boogie warn when the program exits this way, but
apparently so far no action was taken.
_
CAS: why not "assume false" (trivially underapproximate) the excess
iterations, and continue the analysis?

[ ] Smack does not handle bit vectors and bit operations very usefully.
  

Smack Desired Features
----------------------

[ ] add feature that when smack invokes clang, it automatically adds the
appropriate include dir via an -I option so that smack.h can be included as
#include <smack.h> without additional installation-specific dirs being
specified.  It would be acceptable if this needed to be #include
<smack/smack.h> so one -I option could also cover the additional .h files in
the smack installations include tree.  Changes appear to be necessary in
bin/smackgen.py (call to subprocess.Popen()).  Note that a similar change has
already been made in rise4fun/smack_server.py (call to subprocess.call()).

[ ] updated build-linux.sh so it can handle prerequisite systems like corral or
mono being pre-installed on the system, but still need to have symbolic links
pointing to them.  Akin to what I have in TUUT.

[ ] foreach .py file in smack/bin, have a symbolic link pointing to it without
the .py suffix, to save on typing.  For example, a link called foo pointing to
foo.py.

[ ] direct SMACK statements for atomic_begin() and atomic_end().  They can
be implemented differently depending on the back end.

[ ] have a preprocessor symbol #define __SMACK (used to #if out code used
only for verification).

[ ] have a preprocessor symbol specifying which backend SMACK is using, e.g.
#define __SMACK_BACKEND_CORRAL or __SMACK_BACKEND_BOOGIE.  Used to qualify
code in __SMACK_decl*() functions that only makes sense with one backend.

[ ] consider having smack rename the corral object-ish files created to begin
with the unsuffixed basename of the source file.

[ ] allow a -DMACRO=VALUE option on the smack-verify command line.


(end of file)

